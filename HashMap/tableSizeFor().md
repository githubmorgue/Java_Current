# tableSizeFor()

在 JDK 8 的 `java.util.HashMap` 中，`tableSizeFor(int cap)` 方法用于根据用户指定的初始容量 `cap`，计算出一个最接近且不小于该值的 **2 的幂次方**。这是 `HashMap` 内部数组（`table`）长度必须为 2 的幂的核心机制之一。以下是对该方法的详细解析。

---

## **1. 方法定义**
```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

---

## **2. 核心逻辑解析**

### **(1) 初始操作：`n = cap - 1`**
- **目的**：确保即使用户传入的 `cap` 本身就是 2 的幂，也能正确返回它。
- **示例**：
  - 如果 `cap = 8`，则 `n = 7`（二进制为 `0b111`）。
  - 后续操作将 `n` 扩展为全 1 的形式，再 `+1` 即可得到 `8`。

---

### **(2) 位或操作：逐步填充高位**
```java
n |= n >>> 1;
n |= n >>> 2;
n |= n >>> 4;
n |= n >>> 8;
n |= n >>> 16;
```

- **操作目的**：将 `n` 的二进制位中所有高位填充为 `1`，使得 `n` 成为一个全 1 的数。
- **操作原理**：
  - 每次将 `n` 右移若干位并与原 `n` 进行按位或（`|`），逐步将高位的 `1` 向低位扩散。
  - 最终，`n` 将变为一个二进制全 1 的数（例如 `0b11111111`）。

- **示例**：
  - 假设 `cap = 10`，则 `n = 9`（二进制 `0b1001`）。
  - 第一次 `n |= n >>> 1` → `0b1001 | 0b0100 = 0b1101`。
  - 第二次 `n |= n >>> 2` → `0b1101 | 0b0011 = 0b1111`。
  - 后续操作不会改变 `n` 的值，因为已经全为 `1`。
  - 最终 `n + 1 = 16`，即最接近且不小于 `10` 的 2 的幂。

- **位操作覆盖范围**：
  - 对于 `int` 类型（32 位），`n >>> 16` 可以确保覆盖所有高位。
  - 通过逐步右移 `1`、`2`、`4`、`8`、`16` 位，可以高效地将所有高位填充为 `1`。

---

### **(3) 最终返回值**
```java
return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
```

- **边界处理**：
  - 如果 `n < 0`：说明 `cap` 超过 `Integer.MAX_VALUE`，返回最小值 `1`。
  - 如果 `n >= MAXIMUM_CAPACITY`：说明 `n + 1` 超出 `HashMap` 的最大容量限制（默认为 `1 << 30`），返回最大容量。
  - 否则返回 `n + 1`：即最接近且不小于 `cap` 的 2 的幂。

---

## **3. 设计优势**

### **(1) 为什么必须是 2 的幂？**
- **哈希索引计算**：`HashMap` 使用 `(n - 1) & hash` 计算键值对在数组中的索引（等效于 `hash % n`，但更快）。
- **性能要求**：数组长度为 2 的幂时，`(n - 1) & hash` 可以快速定位索引，避免取模运算的开销。

### **(2) 高效性**
- **位操作**：整个方法使用位运算完成，无需循环或条件判断，效率极高。
- **通用性**：无论 `cap` 是否为 2 的幂，都能正确返回最小的 2 的幂。

---

## **4. 示例分析**

### **(1) `cap = 10`**
- `n = 10 - 1 = 9`（`0b1001`）
- `n |= n >>> 1` → `0b1001 | 0b0100 = 0b1101`
- `n |= n >>> 2` → `0b1101 | 0b0011 = 0b1111`
- `n + 1 = 16` → 返回 `16`

### **(2) `cap = 8`**
- `n = 8 - 1 = 7`（`0b0111`）
- 位操作后 `n` 仍为 `7`（全为 1）
- `n + 1 = 8` → 返回 `8`

### **(3) `cap = 1`**
- `n = 0`（`0b0000`）
- 位操作后 `n` 仍为 `0`
- `n + 1 = 1` → 返回 `1`

---

## **5. 总结**

`tableSizeFor(int cap)` 通过一系列位操作，高效地将用户指定的容量转换为最接近的 2 的幂次方。这种设计确保了 `HashMap` 内部数组的长度始终是 2 的幂，从而优化哈希索引计算的性能。整个过程无需循环或条件判断，体现了 Java 在底层数据结构设计上的巧妙与高效。