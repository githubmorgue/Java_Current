# hash()

在 JDK 8 的 `HashMap` 中，==`hash` 方法的设计目的是为了优化哈希值的分布，减少哈希冲突==，从而提高 `HashMap` 的性能。以下是对该方法的详细解析：

---

## **1. 方法定义**
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

- **功能**：
  - 如果 `key` 为 `null`，直接返回 `0`（因为 `null` 的哈希值固定为 `0`）。
  - 如果 `key` 不为 `null`，首先调用 `key.hashCode()` 获取原始哈希码 `h`，然后将 `h` 与 `h` 的高位（右移 16 位后）进行异或操作，得到最终的哈希值。

---

## **2. 核心逻辑解析**

### **(1) 哈希值的计算**
- **原始哈希码**：
  - `key.hashCode()` 是 Java 对象的默认哈希码生成方法。但直接使用 `hashCode` 可能导致高位信息未被充分利用。
  
- **高位异或操作**：
  - `h ^ (h >>> 16)`：将 `h` 的高位与低位进行异或（XOR）操作。
  - **目的**：将高位哈希值的影响扩散到低位，从而在后续的索引计算中（`(n - 1) & hash`）更好地利用哈希值的高位信息。

### **(2) 为什么需要高位异或？**
- **哈希表的容量特性**：
  - `HashMap` 的数组容量始终是 2 的幂（`table.length = 2^n`）。
  - 索引的计算公式为：`index = (n - 1) & hash`，其中 `n` 是数组长度。
  - 由于 `n - 1` 是二进制全 1 的数（例如 `16-1=15`，二进制为 `1111`），`(n - 1) & hash` 实际上是取 `hash` 的低 `log2(n)` 位作为索引。

- **问题**：
  - 如果哈希码的高位信息未被利用，当多个对象的哈希码在低位相同（高位不同）时，它们会被映射到同一个桶中，导致哈希冲突。
  - 例如，如果两个对象的 `hashCode` 分别为 `0x12345678` 和 `0x9ABCDEF0`，它们的低 16 位（`0x5678` 和 `0xDEF0`）可能不同，但如果只取低 8 位（`0x78` 和 `0xF0`），可能会冲突。

- **解决方案**：
  - 通过 `h ^ (h >>> 16)`，将高位的差异扩散到低位。例如：
    - `h = 0x12345678` → `h >>> 16 = 0x00001234` → `h ^ (h >>> 16) = 0x12345678 ^ 0x00001234 = 0x1234444C`。
    - 这样，高位 `0x1234` 的信息被混合到低位中，使得最终的 `hash` 值在 `(n - 1) & hash` 的计算中能更均匀地分布。

### **(3) 性能与效率的平衡**
- **计算成本**：
  - `h ^ (h >>> 16)` 是一个非常轻量的操作（仅需一次位移和一次异或），计算速度快。
  - 相比更复杂的哈希函数（如多次位移和异或），这种设计在速度、效果和资源消耗之间达到了平衡。

- **适用场景**：
  - 对于大多数已合理分布的哈希码（如 `String`、`Integer` 等），高位异或操作的改进效果有限，但对某些特殊场景（如哈希码高位变化大、低位固定）能显著减少冲突。

---

## **3. 注释中的关键点解析**
### **(1) "spreads higher bits of hash to lower"**
- **含义**：将高位哈希值的影响扩散到低位，确保低位在索引计算中能充分利用高位信息。
- **示例**：
  - 如果 `h = 0x12345678`，高位 `0x1234` 与低位 `0x5678` 异或后，结果 `0x1234444C` 的低位包含了高位的信息。

### **(2) "power-of-two masking"**
- **含义**：`HashMap` 的数组容量是 2 的幂，因此索引计算通过 `(n - 1) & hash` 实现（等效于取模运算 `hash % n`）。
- **问题**：
  - 如果哈希码的高位未被利用，当 `n` 较小时（如 `16`），`(n - 1) & hash` 仅使用 `hash` 的低 4 位（`16-1=15`，二进制为 `1111`），高位信息被忽略。

### **(3) "sets of hashes that vary only in bits above the current mask will always collide"**
- **含义**：如果多个对象的哈希码仅在高位（超出当前掩码范围的位）不同，则它们会被映射到同一个桶中。
- **示例**：
  - `h1 = 0x12345678` 和 `h2 = 0x9ABC5678` 的低 16 位相同（`0x5678`），因此在 `(16 - 1) & hash` 的计算中会冲突。

### **(4) "incorporate impact of the highest bits that would otherwise never be used"**
- **含义**：通过高位异或操作，确保高位哈希码的信息被纳入最终的索引计算中，避免高位信息的浪费。

---

## **4. 设计优势**
- **减少哈希冲突**：通过高位异或操作，使哈希值分布更均匀，降低冲突概率。
- **高效计算**：位移和异或操作计算成本低，适合高频调用的 `hash` 方法。
- **兼容性**：在 `HashMap` 扩容时（数组容量翻倍），高位异或操作能减少重新计算索引时的冲突（参考 `resize` 方法）。

---

## **5. 示例分析**
假设 `key.hashCode()` 返回 `0x12345678`（32 位整数）：
1. **原始哈希码**：
   - `h = 0x12345678`（二进制：`0001 0010 0011 0100 0101 0110 0111 1000`）。
2. **高位异或**：
   - `h >>> 16 = 0x00001234`（二进制：`0000 0000 0000 0000 0001 0010 0011 0100`）。
   - `h ^ (h >>> 16) = 0x12345678 ^ 0x00001234 = 0x1234444C`（二进制：`0001 0010 0011 0100 0100 0100 0100 1100`）。

最终的 `hash` 值 `0x1234444C` 在 `(n - 1) & hash` 的计算中，会更均匀地分布到不同的桶中。

---

## **6. 总结**
JDK 8 的 `HashMap.hash` 方法通过高位异或操作，巧妙地将高位哈希信息混合到低位中，解决了因哈希表容量为 2 的幂而导致的高位信息浪费问题。这种设计在减少哈希冲突的同时，保持了极低的计算开销，是 `HashMap` 高效性能的关键之一。